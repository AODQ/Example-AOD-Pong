<html><head>
        <!-- Generated by Ddoc from source\AOD\Entity.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>AODCore.entity</title>
        </head><body>
        <h1>AODCore.entity</h1>
Entities are what the engine uses to render images to the screen. They also
  support collision detection.
<br><br>
<b>Example:</b><br>
<pre class="d_code">  <font color=green>// To create your own entity class
</font>  <font color=blue>class</font> Player {
  <font color=blue>public</font>:
    <font color=blue>this</font>() {
      <font color=blue>super</font>(); <font color=green>// Make sure to call this
</font>      Set_Sprite(Img); <font color=green>// sets sprite
</font>      Set_Size(32, 32, <font color=blue>true</font>); <font color=green>// Set the image &amp; collision size to 32x32 pixels
</font>    }
    <font color=blue>override</font> <font color=blue>void</font> Update() {
      <font color=blue>static</font> <font color=blue>int</font> time = 0;
      ++ time;
      Set_Position(Vector(cos(time), sin(time)));
    }
  }

  <font color=green>// and then to add to the engine
</font>  <font color=blue>auto</font> player = <font color=blue>new</font> Player();
  AOD.Add(player);
</pre>

<br><br>

<dl><dt><big><a name="Entity"></a>class <u>Entity</u>;
</big></dt>
<dd>A basic entity class. If you want collision support you should perhaps use
  AABBEntity or PolyEntity<br><br>

<dl><dt><big><a name="Entity.Type"></a>enum <u>Type</u>: int;
</big></dt>
<dd>The collision type of entity<br><br>

</dd>
<dt><big><a name="Entity.image"></a>protected GLuint <u>image</u>;
</big></dt>
<dd>Current <u>image</u> to render to the screen<br><br>

</dd>
<dt><big><a name="Entity.ID"></a>protected int <u>ID</u>;
</big></dt>
<dd><u>ID</u> within the AOD engine<br><br>

</dd>
<dt><big><a name="Entity.rotation"></a>protected float <u>rotation</u>;
</big></dt>
<dd>Rotation in radians of object (and image)<br><br>

</dd>
<dt><big><a name="Entity.rotation_velocity"></a>protected float <u>rotation_velocity</u>;
</big></dt>
<dd>The amount added to rotation every update frame<br><br>

</dd>
<dt><big><a name="Entity.matrix"></a>protected Matrix <u>matrix</u>;
</big></dt>
<dd>Used to keep track of rotation, translation and scaling<br><br>

</dd>
<dt><big><a name="Entity.type"></a>protected Type <u>type</u>;
</big></dt>
<dd>Collision <u>type</u> of entity<br><br>

</dd>
<dt><big><a name="Entity.position"></a>protected Vector <u>position</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.velocity"></a>protected Vector <u>velocity</u>;
</big></dt>
<dd>Amount added to position every update frame<br><br>

</dd>
<dt><big><a name="Entity.size"></a>protected Vector <u>size</u>;
</big></dt>
<dd>Scale of the object (for collision, does not affect image)<br><br>

</dd>
<dt><big><a name="Entity.image_size"></a>protected Vector <u>image_size</u>;
</big></dt>
<dd>Size of image<br><br>

</dd>
<dt><big><a name="Entity.rotate_origin"></a>protected Vector <u>rotate_origin</u>;
</big></dt>
<dd>The origin of which to apply rotation. Origin default is in the middle
      of the image<br><br>

</dd>
<dt><big><a name="Entity.layer"></a>protected int <u>layer</u>;
</big></dt>
<dd>The <u>layer</u> (z-index) of which the object is located. Used only to determine
      which objects get rendered first<br><br>

</dd>
<dt><big><a name="Entity.alpha"></a>protected float <u>alpha</u>;
</big></dt>
<dd>The <u>alpha</u> of the image<br><br>

</dd>
<dt><big><a name="Entity.flipped_x"></a>protected bool <u>flipped_x</u>;
</big></dt>
<dd>Determines if the image is flipped on the x-axis<br><br>

</dd>
<dt><big><a name="Entity.flipped_y"></a>protected bool <u>flipped_y</u>;
</big></dt>
<dd>Determines if the imagei s flipped on the y-axis<br><br>

</dd>
<dt><big><a name="Entity._UV"></a>protected GLfloat[8] <u>_UV</u>;
</big></dt>
<dd>The UV that determines how the image is rendered<br><br>

</dd>
<dt><big><a name="Entity.transformed"></a>protected bool <u>transformed</u>;
</big></dt>
<dd>Used to determine if the vertices of an entity need to be restructured<br><br>

</dd>
<dt><big><a name="Entity.R_Layer"></a>int <u>R_Layer</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.this"></a>this(int <i>_layer</i> = 0, Type <i>_type</i> = Type.nil);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>int <i>_layer</i></td>
<td><t style="padding-left:3em">Layer that the entity should be rendered (0 is top)</t></td></tr>
<tr><td>Type <i>_type</i></td>
<td><t style="padding-left:3em">Type of Entity</t></td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Ret_ID"></a>int <u>Ret_ID</u>();
</big></dt>
<dd><b>Returns:</b><br>
unique ID of Entity<br><br>

</dd>
<dt><big><a name="Entity.Set_Position"></a>void <u>Set_Position</u>(float <i>x</i>, float <i>y</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Position.2"></a>void <u>Set_Position</u>(Vector <i>v</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Add_Position"></a>void <u>Add_Position</u>(float <i>x</i>, float <i>y</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Add_Position.2"></a>void <u>Add_Position</u>(Vector <i>v</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Position"></a>Vector <u>R_Position</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Sprite"></a>void <u>Set_Sprite</u>(GLuint <i>index</i>, bool <i>reset_size</i> = 0);
</big></dt>
<dd>Sets current image to render for this entity
<br><br>
<b>Params:</b><br>
<table><tr><td>GLuint <i>index</i></td>
<td><t style="padding-left:3em">GL Image to render</t></td></tr>
<tr><td>bool <i>reset_size</i></td>
<td><t style="padding-left:3em">If the size of this entity (and image) should
                     be resized to <i>index</i>' size</t></td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Set_Sprite.2"></a>void <u>Set_Sprite</u>(SheetContainer <i>sc</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Sprite.3"></a>void <u>Set_Sprite</u>(SheetRect <i>sr</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Sprite_Texture"></a>GLuint <u>R_Sprite_Texture</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Rotation"></a>void <u>Set_Rotation</u>(float <i>r</i>);
</big></dt>
<dd>(radians)<br><br>

</dd>
<dt><big><a name="Entity.R_Rotation"></a>float <u>R_Rotation</u>();
</big></dt>
<dd>(radians)<br><br>

</dd>
<dt><big><a name="Entity.Add_Velocity"></a>void <u>Add_Velocity</u>(Vector <i>force</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Velocity"></a>void <u>Set_Velocity</u>(Vector <i>vel</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Velocity.2"></a>void <u>Set_Velocity</u>(float <i>x</i>, float <i>y</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Torque"></a>void <u>Set_Torque</u>(float <i>t</i>);
</big></dt>
<dd>The amount added to rotation every update frame<br><br>

</dd>
<dt><big><a name="Entity.Set_Sprite_Frame"></a>void <u>Set_Sprite_Frame</u>(float <i>left_x</i>, float <i>top_y</i>, float <i>right_x</i>, float <i>bot_y</i>);
</big></dt>
<dd>Sets the subsection of the image to be rendered<br><br>

</dd>
<dt><big><a name="Entity.Set_UVs"></a>void <u>Set_UVs</u>(Vector <i>left</i>, Vector <i>right</i>, bool <i>reset_flip</i> = 1);
</big></dt>
<dd>Sets the UV directly<br><br>

</dd>
<dt><big><a name="Entity.R_UVs"></a>void <u>R_UVs</u>(ref Vector <i>left</i>, ref Vector <i>right</i>);
</big></dt>
<dd>Sets UV to passed in paremeters
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector <i>left</i></td>
<td><t style="padding-left:3em">[ UV[2]</t></td></tr>
<tr><td>Vector <i>right</i></td>
<td><t style="padding-left:3em">[ UV[4]</t></td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.R_UV_Array"></a>auto <u>R_UV_Array</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Flip_X"></a>void <u>Flip_X</u>();
</big></dt>
<dd>Flips the image on the x-axis<br><br>

</dd>
<dt><big><a name="Entity.Flip_Y"></a>void <u>Flip_Y</u>();
</big></dt>
<dd>Flips the image on the y-axis<br><br>

</dd>
<dt><big><a name="Entity.Set_Size"></a>void <u>Set_Size</u>(Vector <i>vec</i>, bool <i>scale_image</i> = 0);
</big></dt>
<dd>Sets the size of the entity
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector <i>vec</i></td>
<td><t style="padding-left:3em">Size of the entity (in pixels)</t></td></tr>
<tr><td>bool <i>scale_image</i></td>
<td><t style="padding-left:3em">If the size should scale the image as well</t></td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Set_Size.2"></a>void <u>Set_Size</u>(int <i>x</i>, int <i>y</i>, bool <i>scale_image</i> = 0);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Image_Size"></a>void <u>Set_Image_Size</u>(Vector <i>vec</i>);
</big></dt>
<dd>Sets the size of the image itself, does not affect the entity<br><br>

</dd>
<dt><big><a name="Entity.Set_Visible"></a>void <u>Set_Visible</u>(bool <i>v</i>);
</big></dt>
<dd>Sets if the entity should be rendered or not<br><br>

</dd>
<dt><big><a name="Entity.R_Size"></a>Vector <u>R_Size</u>();
</big></dt>
<dd><b>Returns:</b><br>
size of the entity itself<br><br>

</dd>
<dt><big><a name="Entity.R_Img_Size"></a>Vector <u>R_Img_Size</u>();
</big></dt>
<dd><b>Returns:</b><br>
the size of the image<br><br>

</dd>
<dt><big><a name="Entity.Set_Colour"></a>void <u>Set_Colour</u>(float <i>r</i> = 1, float <i>g</i> = 1, float <i>b</i> = 1, float <i>a</i> = 1);
</big></dt>
<dd>Sets the colour of the image<br><br>

</dd>
<dt><big><a name="Entity.Cancel_Colour"></a>void <u>Cancel_Colour</u>();
</big></dt>
<dd>Cancels manually overriding the colour of the image<br><br>

</dd>
<dt><big><a name="Entity.Set_Is_Static_Pos"></a>void <u>Set_Is_Static_Pos</u>(bool <i>s</i>);
</big></dt>
<dd>Sets if the position should be static (its position relative to the
      camera is irrelevant)<br><br>

</dd>
<dt><big><a name="Entity.Set_Origin"></a>void <u>Set_Origin</u>(Vector <i>v</i>);
</big></dt>
<dd>Sets the origin of the entity (default is the center of the image size)<br><br>

</dd>
<dt><big><a name="Entity.Clear_Origin"></a>void <u>Clear_Origin</u>();
</big></dt>
<dd>Resets origin to the center of the image size<br><br>

</dd>
<dt><big><a name="Entity.R_Origin"></a>Vector <u>R_Origin</u>();
</big></dt>
<dd><b>Returns:</b><br>
the current origin of the image<br><br>

</dd>
<dt><big><a name="Entity.R_Green"></a>float <u>R_Green</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Red"></a>float <u>R_Red</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Blue"></a>float <u>R_Blue</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Alpha"></a>float <u>R_Alpha</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Is_Coloured"></a>bool <u>R_Is_Coloured</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Is_Visible"></a>bool <u>R_Is_Visible</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Is_Static_Pos"></a>bool <u>R_Is_Static_Pos</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Flipped_X"></a>bool <u>R_Flipped_X</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Flipped_Y"></a>bool <u>R_Flipped_Y</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Type"></a>Type <u>R_Type</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Matrix"></a>Matrix <u>R_Matrix</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Collision"></a>Collision_Info <u>Collision</u>(Entity <i>o</i>);
</big></dt>
<dd>Determines if there is a collision between this entity and another
<br><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the other<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PolyEnt"></a>class <u>PolyEnt</u>: <u>AODCore.entity.Entity</u>;
</big></dt>
<dd>An entity that uses polygon collision (only supports convex polygons)<br><br>

<dl><dt><big><a name="PolyEnt.this"></a>this();
</big></dt>
<dd>Constructs an entity that has no vertices<br><br>

</dd>
<dt><big><a name="PolyEnt.this.2"></a>this(Vector[] <i>vertices_</i>, Vector <i>off</i> = Vector(0, 0));
</big></dt>
<dd>Constructs an entity
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector[] <i>vertices_</i></td>
<td><t style="padding-left:3em">Vertices to construct polygon with (must be
                    convex and in) counter-clockwise order</t>;</td></tr>
<tr><td>Vector <i>off</i></td>
<td><t style="padding-left:3em">Sets position of entity</t></td></tr>
</table><br>

</dd>
<dt><big><a name="PolyEnt.Set_Vertices"></a>void <u>Set_Vertices</u>(Vector[] <i>vertices_</i>, bool <i>reorder</i> = 1);
</big></dt>
<dd>Resets vertices of entity
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector[] <i>vertices_</i></td>
<td><t style="padding-left:3em">Vertices to construct polygon with
                    (must be convex)</t></td></tr>
<tr><td>bool <i>reorder</i></td>
<td><t style="padding-left:3em">If set</t></td></tr>
</table><br>

</dd>
<dt><big><a name="PolyEnt.R_Vertices"></a>Vector[] <u>R_Vertices</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="PolyEnt.R_Transformed_Vertices"></a>Vector[] <u>R_Transformed_Vertices</u>(bool <i>force</i> = 0);
</big></dt>
<dd><b>Returns:</b><br>
Vertices transformed by the entity's matrix<br><br>

</dd>
<dt><big><a name="PolyEnt.Collide"></a>Collision_Info <u>Collide</u>(PolyEnt <i>poly</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another PolyEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>PolyEnt <i>poly</i></td>
<td><t style="padding-left:3em">Another PolyEntity</t></td></tr>
<tr><td>Vector <i>velocity</i></td>
<td><t style="padding-left:3em">Velocity for which to check collision</t></td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the <i>poly</i><br><br>

</dd>
<dt><big><a name="PolyEnt.Collide.2"></a>Collision_Info <u>Collide</u>(AABBEnt <i>aabb</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another AABBEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>AABBEnt <i>aabb</i></td>
<td><t style="padding-left:3em">Another AABBEntity</t></td></tr>
<tr><td>Vector <i>velocity</i></td>
<td><t style="padding-left:3em">Velocity for which to check collision</t></td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the AABB<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="AABBEnt"></a>class <u>AABBEnt</u>: <u>AODCore.entity.PolyEnt</u>;
</big></dt>
<dd>An entity that supports Axis-Aligned-Bounding-Box collision (a rectangle with
  no rotation). If rotation is required, use a PolyEntity instead.<br><br>

<dl><dt><big><a name="AABBEnt.this"></a>this(Vector <i>size</i> = Vector(0, 0));
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Vector <i>size</i></td>
<td><t style="padding-left:3em">Size of the bounding-box</t></td></tr>
</table><br>

</dd>
<dt><big><a name="AABBEnt.this.2"></a>this(Vector <i>size</i> = Vector(0, 0), Vector <i>pos</i> = Vector(0, 0));
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Vector <i>size</i></td>
<td><t style="padding-left:3em">Size of the bounding-box</t></td></tr>
<tr><td>Vector <i>pos</i></td>
<td><t style="padding-left:3em">Position of the entity</t></td></tr>
</table><br>

</dd>
<dt><big><a name="AABBEnt.Collide"></a>Collision_Info <u>Collide</u>(AABBEnt <i>aabb</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another AABBEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>AABBEnt <i>aabb</i></td>
<td><t style="padding-left:3em">Another AABBEntity</t></td></tr>
<tr><td>Vector <i>velocity</i></td>
<td><t style="padding-left:3em">Velocity for which to check collision</t></td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the AABB<br><br>

</dd>
<dt><big><a name="AABBEnt.Collide.2"></a>Collision_Info <u>Collide</u>(PolyEnt <i>poly</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another PolyEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>PolyEnt <i>poly</i></td>
<td><t style="padding-left:3em">Another PolyEntity</t></td></tr>
<tr><td>Vector <i>velocity</i></td>
<td><t style="padding-left:3em">Velocity for which to check collision</t></td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the <i>poly</i><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Collision_Info"></a>struct <u>Collision_Info</u>;
</big></dt>
<dd>Gives information about a collision.<br><br>

<dl><dt><big><a name="Collision_Info.collision"></a>bool <u>collision</u>;
</big></dt>
<dd>Determines if there is currently a <u>collision</u><br><br>

</dd>
<dt><big><a name="Collision_Info.will_collide"></a>bool <u>will_collide</u>;
</big></dt>
<dd>Determines if there will be a collision if the velocity were added
       to the position<br><br>

</dd>
<dt><big><a name="Collision_Info.translation"></a>Vector <u>translation</u>;
</big></dt>
<dd>Gives the amount of <u>translation</u> required to no longer be colliding<br><br>

</dd>
<dt><big><a name="Collision_Info.projection"></a>Vector <u>projection</u>;
</big></dt>
<dd>The axis/<u>projection</u> of the collision<br><br>

</dd>
<dt><big><a name="Collision_Info.normal"></a>Vector <u>normal</u>;
</big></dt>
<dd>TBD<br><br>

</dd>
<dt><big><a name="Collision_Info.obj"></a>PolyEnt <u>obj</u>;
</big></dt>
<dd>The object that was collided with<br><br>

</dd>
<dt><big><a name="Collision_Info.this"></a>this(bool <i>c</i>);
</big></dt>
<dd>basic form of Collision_Info
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>c</i></td>
<td><t style="padding-left:3em">If there was a collision</t></td></tr>
</table><br>

</dd>
<dt><big><a name="Collision_Info.this.2"></a>this(ref Vector <i>t</i>, bool <i>c</i>, bool <i>wc</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Vector <i>t</i></td>
<td><t style="padding-left:3em">Translation of the collision</t></td></tr>
<tr><td>bool <i>c</i></td>
<td><t style="padding-left:3em">If there was a collision</t></td></tr>
<tr><td>bool <i>wc</i></td>
<td><t style="padding-left:3em">If there will be a collision</t></td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
